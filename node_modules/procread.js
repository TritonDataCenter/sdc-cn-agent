/*
 * This Source Code Form is subject to the terms of the Mozilla Public
 * License, v. 2.0. If a copy of the MPL was not distributed with this
 * file, You can obtain one at http://mozilla.org/MPL/2.0/.
 */

/*
 * Copyright (c) 2014, Joyent, Inc.
 */

var async = require('async');
var ctype = require('ctype');
var execFile = require('child_process').execFile;
var fs = require('fs');

// output from `ctf2json -f /lib/libc.so -t psinfo_t | json`
var psinfo_ctf = {
  "metadata": {
    "ctf2json_version": "1.0",
    "created_at": 1419184213,
    "derived_from": "/lib/libc.so",
    "ctf_version": 2,
    "requested_types": [
      "psinfo_t"
    ]
  },
  "data": [
    {
      "name": "int",
      "integer": {
        "length": 4,
        "signed": true
      }
    },
    {
      "name": "long",
      "integer": {
        "length": 4,
        "signed": true
      }
    },
    {
      "name": "pid_t",
      "typedef": "long"
    },
    {
      "name": "unsigned int",
      "integer": {
        "length": 4,
        "signed": false
      }
    },
    {
      "name": "uid_t",
      "typedef": "unsigned int"
    },
    {
      "name": "gid_t",
      "typedef": "unsigned int"
    },
    {
      "name": "uintptr_t",
      "typedef": "unsigned int"
    },
    {
      "name": "size_t",
      "typedef": "unsigned int"
    },
    {
      "name": "unsigned long",
      "integer": {
        "length": 4,
        "signed": false
      }
    },
    {
      "name": "dev_t",
      "typedef": "unsigned long"
    },
    {
      "name": "unsigned short",
      "integer": {
        "length": 2,
        "signed": false
      }
    },
    {
      "name": "ushort_t",
      "typedef": "unsigned short"
    },
    {
      "name": "time_t",
      "typedef": "long"
    },
    {
      "name": "struct timespec",
      "struct": [
        {
          "name": "tv_sec",
          "type": "time_t"
        },
        {
          "name": "tv_nsec",
          "type": "long"
        }
      ]
    },
    {
      "name": "timestruc_t",
      "typedef": "struct timespec"
    },
    {
      "name": "char",
      "integer": {
        "length": 1,
        "signed": true
      }
    },
    {
      "name": "id_t",
      "typedef": "long"
    },
    {
      "name": "taskid_t",
      "typedef": "long"
    },
    {
      "name": "projid_t",
      "typedef": "long"
    },
    {
      "name": "poolid_t",
      "typedef": "long"
    },
    {
      "name": "zoneid_t",
      "typedef": "long"
    },
    {
      "name": "short",
      "integer": {
        "length": 2,
        "signed": true
      }
    },
    {
      "name": "processorid_t",
      "typedef": "int"
    },
    {
      "name": "psetid_t",
      "typedef": "int"
    },
    {
      "name": "struct lwpsinfo",
      "struct": [
        {
          "name": "pr_flag",
          "type": "int"
        },
        {
          "name": "pr_lwpid",
          "type": "id_t"
        },
        {
          "name": "pr_addr",
          "type": "uintptr_t"
        },
        {
          "name": "pr_wchan",
          "type": "uintptr_t"
        },
        {
          "name": "pr_stype",
          "type": "char"
        },
        {
          "name": "pr_state",
          "type": "char"
        },
        {
          "name": "pr_sname",
          "type": "char"
        },
        {
          "name": "pr_nice",
          "type": "char"
        },
        {
          "name": "pr_syscall",
          "type": "short"
        },
        {
          "name": "pr_oldpri",
          "type": "char"
        },
        {
          "name": "pr_cpu",
          "type": "char"
        },
        {
          "name": "pr_pri",
          "type": "int"
        },
        {
          "name": "pr_pctcpu",
          "type": "ushort_t"
        },
        {
          "name": "pr_pad",
          "type": "ushort_t"
        },
        {
          "name": "pr_start",
          "type": "timestruc_t"
        },
        {
          "name": "pr_time",
          "type": "timestruc_t"
        },
        {
          "name": "pr_clname",
          "type": "char [8]"
        },
        {
          "name": "pr_name",
          "type": "char [16]"
        },
        {
          "name": "pr_onpro",
          "type": "processorid_t"
        },
        {
          "name": "pr_bindpro",
          "type": "processorid_t"
        },
        {
          "name": "pr_bindpset",
          "type": "psetid_t"
        },
        {
          "name": "pr_lgrp",
          "type": "int"
        },
        {
          "name": "pr_filler",
          "type": "int [4]"
        }
      ]
    },
    {
      "name": "lwpsinfo_t",
      "typedef": "struct lwpsinfo"
    },
    {
      "name": "struct psinfo",
      "struct": [
        {
          "name": "pr_flag",
          "type": "int"
        },
        {
          "name": "pr_nlwp",
          "type": "int"
        },
        {
          "name": "pr_pid",
          "type": "pid_t"
        },
        {
          "name": "pr_ppid",
          "type": "pid_t"
        },
        {
          "name": "pr_pgid",
          "type": "pid_t"
        },
        {
          "name": "pr_sid",
          "type": "pid_t"
        },
        {
          "name": "pr_uid",
          "type": "uid_t"
        },
        {
          "name": "pr_euid",
          "type": "uid_t"
        },
        {
          "name": "pr_gid",
          "type": "gid_t"
        },
        {
          "name": "pr_egid",
          "type": "gid_t"
        },
        {
          "name": "pr_addr",
          "type": "uintptr_t"
        },
        {
          "name": "pr_size",
          "type": "size_t"
        },
        {
          "name": "pr_rssize",
          "type": "size_t"
        },
        {
          "name": "pr_pad1",
          "type": "size_t"
        },
        {
          "name": "pr_ttydev",
          "type": "dev_t"
        },
        {
          "name": "pr_pctcpu",
          "type": "ushort_t"
        },
        {
          "name": "pr_pctmem",
          "type": "ushort_t"
        },
        {
          "name": "pr_start",
          "type": "timestruc_t"
        },
        {
          "name": "pr_time",
          "type": "timestruc_t"
        },
        {
          "name": "pr_ctime",
          "type": "timestruc_t"
        },
        {
          "name": "pr_fname",
          "type": "char [16]"
        },
        {
          "name": "pr_psargs",
          "type": "char [80]"
        },
        {
          "name": "pr_wstat",
          "type": "int"
        },
        {
          "name": "pr_argc",
          "type": "int"
        },
        {
          "name": "pr_argv",
          "type": "uintptr_t"
        },
        {
          "name": "pr_envp",
          "type": "uintptr_t"
        },
        {
          "name": "pr_dmodel",
          "type": "char"
        },
        {
          "name": "pr_pad2",
          "type": "char [3]"
        },
        {
          "name": "pr_taskid",
          "type": "taskid_t"
        },
        {
          "name": "pr_projid",
          "type": "projid_t"
        },
        {
          "name": "pr_nzomb",
          "type": "int"
        },
        {
          "name": "pr_poolid",
          "type": "poolid_t"
        },
        {
          "name": "pr_zoneid",
          "type": "zoneid_t"
        },
        {
          "name": "pr_contract",
          "type": "id_t"
        },
        {
          "name": "pr_filler",
          "type": "int [1]"
        },
        {
          "name": "pr_lwp",
          "type": "lwpsinfo_t"
        }
      ]
    },
    {
      "name": "psinfo_t",
      "typedef": "struct psinfo"
    }
  ]
};

/*
 * From:
 *
 * $ cat foo.c
 * #include <sys/procfs.h>
 *
 * prusage_t foo;
 *
 * $ gcc -g -c foo.c
 * $ ctfconvert -L VERSION foo.o
 * $ ctf2json -f foo.o -t prusage_t | json
 */
prusage_ctf = {
  "metadata": {
    "ctf2json_version": "1.0",
    "created_at": 1419191915,
    "derived_from": "foo.o",
    "ctf_version": 2,
    "requested_types": [
      "prusage_t"
    ]
  },
  "data": [
    {
      "name": "long",
      "integer": {
        "length": 4,
        "signed": true
      }
    },
    {
      "name": "time_t",
      "typedef": "long"
    },
    {
      "name": "struct timespec",
      "struct": [
        {
          "name": "tv_sec",
          "type": "time_t"
        },
        {
          "name": "tv_nsec",
          "type": "long"
        }
      ]
    },
    {
      "name": "id_t",
      "typedef": "long"
    },
    {
      "name": "int",
      "integer": {
        "length": 4,
        "signed": true
      }
    },
    {
      "name": "timestruc_t",
      "typedef": "struct timespec"
    },
    {
      "name": "unsigned long",
      "integer": {
        "length": 4,
        "signed": false
      }
    },
    {
      "name": "ulong_t",
      "typedef": "unsigned long"
    },
    {
      "name": "struct prusage",
      "struct": [
        {
          "name": "pr_lwpid",
          "type": "id_t"
        },
        {
          "name": "pr_count",
          "type": "int"
        },
        {
          "name": "pr_tstamp",
          "type": "timestruc_t"
        },
        {
          "name": "pr_create",
          "type": "timestruc_t"
        },
        {
          "name": "pr_term",
          "type": "timestruc_t"
        },
        {
          "name": "pr_rtime",
          "type": "timestruc_t"
        },
        {
          "name": "pr_utime",
          "type": "timestruc_t"
        },
        {
          "name": "pr_stime",
          "type": "timestruc_t"
        },
        {
          "name": "pr_ttime",
          "type": "timestruc_t"
        },
        {
          "name": "pr_tftime",
          "type": "timestruc_t"
        },
        {
          "name": "pr_dftime",
          "type": "timestruc_t"
        },
        {
          "name": "pr_kftime",
          "type": "timestruc_t"
        },
        {
          "name": "pr_ltime",
          "type": "timestruc_t"
        },
        {
          "name": "pr_slptime",
          "type": "timestruc_t"
        },
        {
          "name": "pr_wtime",
          "type": "timestruc_t"
        },
        {
          "name": "pr_stoptime",
          "type": "timestruc_t"
        },
        {
          "name": "filltime",
          "type": "timestruc_t [6]"
        },
        {
          "name": "pr_minf",
          "type": "ulong_t"
        },
        {
          "name": "pr_majf",
          "type": "ulong_t"
        },
        {
          "name": "pr_nswap",
          "type": "ulong_t"
        },
        {
          "name": "pr_inblk",
          "type": "ulong_t"
        },
        {
          "name": "pr_oublk",
          "type": "ulong_t"
        },
        {
          "name": "pr_msnd",
          "type": "ulong_t"
        },
        {
          "name": "pr_mrcv",
          "type": "ulong_t"
        },
        {
          "name": "pr_sigs",
          "type": "ulong_t"
        },
        {
          "name": "pr_vctx",
          "type": "ulong_t"
        },
        {
          "name": "pr_ictx",
          "type": "ulong_t"
        },
        {
          "name": "pr_sysc",
          "type": "ulong_t"
        },
        {
          "name": "pr_ioch",
          "type": "ulong_t"
        },
        {
          "name": "filler",
          "type": "ulong_t [10]"
        }
      ]
    },
    {
      "name": "prusage_t",
      "typedef": "struct prusage"
    }
  ]
};

// XXX would like pstatus_t (from /proc/PID/status) but node-ctype breaks on it

// from https://github.com/TritonDataCenter/sdc-cloud-analytics/blob/release-20141211/lib/ca/ca-proc.js#L37
function indexOfNullTerminator(buffer)
{
    var ii;

    for (ii = 0; ii < buffer.length; ii++) {
        if (buffer[ii] === 0) {
            return (ii);
        }
    }

    return (ii);
}

function numberTime(timespec)
{
    return timespec.tv_sec + (timespec.tv_nsec / 1000000000);
}

function getZoneid(zonename, callback)
{
    var args = ['-z', zonename, 'list', '-p'];
    var cmd = '/usr/sbin/zoneadm';

    execFile(cmd, args, function (error, stdout, stderr) {
        if (error) {
            console.error('Unable to get zoneadm info');
            error.stdout = stdout;
            error.stderr = stderr;
            callback(error);
        } else {
            zoneid = stdout.split(':')[0];
            callback(null, zoneid);
        }
    });
}

function getPstatus(pid, callback) {
    fs.readFile('/proc/' + pid + '/status', function (err, buf) {
        var parser;
        var parsed;

        if (err) {
            if (err.code === 'ENOENT') {
                callback(null, {});
                return;
            }
            callback(err);
            return;
        }

        // create a parser
        parser = ctype.parseCTF(pstatus_ctf, {
            'endian': 'little',
            'char-type': 'uint8'
        });

        // parse the data for this usage file with that parser
        parsed = parser.readData([{pstatus: {type: 'pstatus_t'}}], buf, 0);

        //
        // Fix wierd data so clients don't have to
        //

        callback(null, parsed.pstatus);
    });
}
function getPrusage(pid, callback) {
    fs.readFile('/proc/' + pid + '/usage', function (err, buf) {
        var parser;
        var parsed;

        if (err) {
            return callback(err);
        }

        // create a parser
        parser = ctype.parseCTF(prusage_ctf, {
            'endian': 'little',
            'char-type': 'uint8'
        });

        // parse the data for this usage file with that parser
        parsed = parser.readData([{prusage: {type: 'prusage_t'}}], buf, 0);

        //
        // Fix wierd data so clients don't have to
        //

        // Fix times
        [
            'pr_tstamp',
            'pr_create',
            'pr_term',
            'pr_rtime',
            'pr_utime',
            'pr_stime',
            'pr_ttime',
            'pr_tftime',
            'pr_dftime',
            'pr_kftime',
            'pr_ltime',
            'pr_slptime',
            'pr_wtime',
            'pr_stoptime'
        ].forEach(function (timefield) {
            parsed.prusage[timefield] = numberTime(parsed.prusage[timefield]);
        });

        // Delete junk
        delete parsed.prusage.filler;
        delete parsed.prusage.filltime;

        callback(null, parsed.prusage);
    });
}

function getPsinfo(zoneid, pid, callback) {
    fs.readFile('/proc/' + pid + '/psinfo', function (err, buf) {
        var parser;
        var parsed;

        if (err) {
            return callback(err);
        }

        // create a parser
        parser = ctype.parseCTF(psinfo_ctf, {
            'endian': 'little',
            'char-type': 'uint8'
        });

        // parse the data for this psinfo file with that parser
        parsed = parser.readData([{psinfo: {type: 'psinfo_t'}}], buf, 0);

        if (parsed.psinfo.pr_zoneid !== zoneid) {
            // not the droids we're looking for
            callback();
            return;
        }

        //
        // Fix wierd data so clients don't have to
        //

        // Fix strings
        ['pr_psargs', 'pr_fname'].forEach(function (str_field) {
            parsed.psinfo[str_field] = parsed.psinfo[str_field]
                .toString('ascii', 0,
                    indexOfNullTerminator(parsed.psinfo[str_field])
            );
        });
        ['pr_clname', 'pr_name'].forEach(function (str_field) {
            parsed.psinfo.pr_lwp[str_field] = parsed.psinfo.pr_lwp[str_field]
                .toString('ascii', 0,
                    indexOfNullTerminator(parsed.psinfo.pr_lwp[str_field])
            );
        });
        parsed.psinfo.pr_lwp.pr_sname
            = String.fromCharCode(parsed.psinfo.pr_lwp.pr_sname);

        // Fix times
        parsed.psinfo.pr_ctime = numberTime(parsed.psinfo.pr_ctime);
        parsed.psinfo.pr_start = numberTime(parsed.psinfo.pr_start);
        parsed.psinfo.pr_time = numberTime(parsed.psinfo.pr_time);
        parsed.psinfo.pr_lwp.pr_start
            = numberTime(parsed.psinfo.pr_lwp.pr_start);
        parsed.psinfo.pr_lwp.pr_time = numberTime(parsed.psinfo.pr_lwp.pr_time);

        // Fix data that's stored weird
        parsed.psinfo.pr_lwp.pr_nice -= 20; // stored 0-39

        // Delete junk
        delete parsed.psinfo.pr_filler;
        delete parsed.psinfo.pr_pad;
        delete parsed.psinfo.pr_pad1;
        delete parsed.psinfo.pr_pad2;
        delete parsed.psinfo.pr_lwp.pr_filler;
        delete parsed.psinfo.pr_lwp.pr_pad;

        callback(null, parsed.psinfo);
    });
}

function getZoneProcInfo(zoneid, pid, callback)
{
    var procinfo = {};

    getPsinfo(zoneid, pid, function (error, psinfo) {
        if (error) {
            callback(error);
            return;
        }
        if (!psinfo) {
            // This means the process is not for our zone.
            callback();
            return;
        }
        procinfo.psinfo = psinfo;

        // We want data about this
        getPrusage(pid, function (err, prusage) {
            if (err) {
                callback(err);
                return;
            }
            procinfo.prusage = prusage;

            callback(null, procinfo);
        });
    });
}

function getZoneProcs(zonename, callback)
{
    getZoneid(zonename, function (error, zoneid) {
        if (error) {
            console.error(error.message);
            return;
        }

        fs.readdir('/proc', function (err, files) {
            var procs = [];

            async.each(files, function (pid, cb) {
                if (pid.match(/^[0-9]+$/)) {
                    getZoneProcInfo(Number(zoneid), pid, function (e, data) {
                        if (e) {
                            cb(e);
                            return;
                        }
                        if (data) {
                            procs.push(data);
                        }
                        cb();
                    });
                } else {
                    cb();
                }
            }, function (err) {
                callback(null, procs);
            });
        });
    });
}

module.exports = {
    getZoneProcs: getZoneProcs
};
